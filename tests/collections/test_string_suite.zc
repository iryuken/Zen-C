
include <string.h>
include <stdio.h>
import "std.zc"

test "test_string_methods" {
    println "Testing String methods...";
    
    // Substring
    var s1: String = String::from("Hello World");
    var sub: String = String::substring(&s1, 0, 5);
    var expected1: String = String::from("Hello");
    if (String::eq(&sub, expected1)) {
        println "  -> substring(0, 5): Passed";
    } else {
        assert(false, "substring(0, 5) failed");
    }
    
    // Substring middle
    var sub2: String = String::substring(&s1, 6, 5);
    var expected2: String = String::from("World");
    if (String::eq(&sub2, expected2)) {
        println "  -> substring(6, 5): Passed";
    } else {
        assert(false, "substring(6, 5) failed");
    }
    
    // Find
    var pos = String::find(&s1, 'W');
    if (pos.is_some) {
        var idx = pos.unwrap();
        if (idx == 6) {
             println "  -> find('W'): Passed";
        } else {
             assert(false, "find('W') returned wrong index");
        }
    } else {
         assert(false, "find('W') failed to find char");
    }
    
    var pos2 = String::find(&s1, 'Z');
    if (pos2.is_none()) {
         println "  -> find('Z'): Passed (Correctly not found)";
    } else {
         assert(false, "find('Z') should have returned none");
    }

    // Length
    var len = String::length(&s1);
    if (len == 11) {
        println "  -> length(): Passed";
    } else {
        assert(false, "length() failed");
    }
    
    // Contains
    if (s1.contains('W')) {
        println "  -> contains('W'): Passed";
    } else {
        assert(false, "contains('W') failed");
    }
    
    if (!s1.contains('Z')) {
        println "  -> !contains('Z'): Passed";
    } else {
        assert(false, "!contains('Z') failed");
    }

    // Cleanup
    s1.free();
    sub.free();
    sub2.free();
    expected1.free();
    expected2.free();
    
    // Append
    println "Testing String Append...";
    var s2 = String::from("Hello");
    var s3 = String::from(" World");
    String::append(&s2, s3);
    var expected_full = String::from("Hello World");
    
    if (String::eq(&s2, expected_full)) {
        println "  -> append(): Passed";
    } else {
        assert(false, "append() failed");
    }
    
    s2.free();
    s3.free(); // Free the wrapper...
    expected_full.free();
    
    println "All String methods passed!";
}

test "test_fstrings_return" {
    println "Testing F-Strings and Returns...";
    var x = 100;
    var y = 50;

    println "Direct F-String: x={x}";
    var nested = f"y is {y}";
    println "Argument F-String: {nested}";
    println "Math inside: 100 + 50 = {x + y}";
    
    var inner = f"Inner({x})";
    var outer = f"Outer({inner})";
    println "Composed: {outer}";
    assert(strcmp(outer, "Outer(Inner(100))") == 0, "Composed f-string failed");
}

test "test_string_std_ops" {
    println "Testing String Std Ops...";
    var s1 = String::from("Hello");
    var s2 = String::from(" World");
    
    var s3 = s1 + s2; 
    
    print "Concatenated: ";
    s3.println();
    
    assert(s3.length() == 11, "Length mismatch");

    var s4 = String::from("Hello World");
    if (s3.eq(s4)) {
        println "Equality check passed: Strings are identical.";
    } else {
        assert(false, "Equality check failed");
    }
}
