import "./core.zc"
import "./option.zc"
import "./string.zc"

include <stdlib.h>

extern fn getenv(name: const char*) -> char*;

// Cross-platform environment variable handling
raw {
    int _z_setenv(const char* name, const char* value, int overwrite) {
#ifdef _WIN32
        if (!overwrite && getenv(name) != NULL) return 0;
        return _putenv_s(name, value);
#else
        return setenv(name, value, overwrite);
#endif
    }

    int _z_unsetenv(const char* name) {
#ifdef _WIN32
        char* buf = malloc(strlen(name) + 2);
        if (!buf) return -1;
        sprintf(buf, "%s=", name);
        int ret = _putenv(buf);
        free(buf);
        return ret;
#else
        return unsetenv(name);
#endif
    }
}

extern fn _z_setenv(name: const char*, value: const char*, overwrite: int) -> int;
extern fn _z_unsetenv(name: const char*) -> int;

@derive(Eq)
enum EnvRes {
    ERR,
    OK,
}

struct Env {}

impl Env {
    fn get(name: string) -> Option<string> {
        let value: string = getenv(name);
        if (value == NULL) {
            return Option<string>::None();
        }

        return Option<string>::Some(value);
    }

    fn get_dup(name: string) -> Option<String> {
        let value: string = getenv(name);
        if (value == NULL) {
            return Option<String>::None();
        }

        let v = String::from(value);
        let o = Option<String>::Some(v);
        v.forget();

        return o;
    }

    fn set(name: string, value: string) -> EnvRes {
        let ret: int = _z_setenv(name, value, 1);

        return (ret == 0) ? EnvRes::OK() : EnvRes::ERR();
    }

    fn unset(name: string) -> EnvRes {
        let ret: int = _z_unsetenv(name);

        return (ret == 0) ? EnvRes::OK() : EnvRes::ERR();
    }
}
